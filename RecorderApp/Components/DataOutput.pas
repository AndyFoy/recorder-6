{ DataOutput - contains TDataOutput class which initiates the output of an XML
     file }
unit DataOutput;

interface

uses
  Sysutils, Classes, FileOutput, JNCCRelationships, DataClasses, JNCCDatasets,
  Db, ExceptionForm, JNCCXMLDoc, XMLTypes, SQLConstants;

resourcestring
  ResStr_ExportDataUnsuitable = 'The data selected for export is not suitable ' +
      'for exporting as XML data.';
  ResStr_FileVersion = '<!--NBNData XML Output generated by Recorder 6 version %s-->';

type
  EDataOutputError = class(EFileOutputError);
  EJNCCDataOutputError = class(EDataOutputError);


  TDataOutput = class(TFileOutput)
  private
    FDTD : TXMLDoc; // document type definition
    FUsedRelationships : TStringList;
    FRecordsAlreadyOutput : TStringList;
  protected
    procedure PickupObservations(iKeyList: TEditableKeyList);
    procedure InitiateOutput(fromExportFilter: Boolean); virtual;
    procedure OutputXMLVersion;
    procedure OutputDocTypeDeclaration;
    procedure OutputAppVersion;
    function IsKeyItemInTable(iKeyList: TKeyList; const iIndex : integer;
      const iTable: string): boolean;
  public
    constructor Create( const iFileName : string );
    destructor Destroy; override;
    procedure Execute(iKeyList: TEditableKeyList; AInvalidKeys: TKeyList;
        const iWantObservations, iFromExportFilter: boolean);
  end; // TDataOutput

implementation

uses
  Relationships_ADO, XMLData, ApplicationSettings, GeneralData, VersionInfo;

//==============================================================================
{ TDataOutput }
//==============================================================================

{ constructor - set up necessary string lists }
constructor TDataOutput.Create( const iFileName : string );
begin
  inherited Create( iFileName );
  FDTD := TXMLDoc.Create( AppSettings.DTDPath + INPUT_FILE, self, nil);
  FDTD.ProcessDocument(true);
  { List to identify all the relationships we have already followed so we don't
       follow them twice and 'bounce' backwards and forwards along the same
       relationship }
  FUsedRelationships := TStringList.Create;
  { List to identify all the records already output in the XML file so we
       don't duplicate them }
  FRecordsAlreadyOutput := TStringList.Create;
end;


{ Destructor - free relevant string lists }
destructor TDataOutput.Destroy;
begin
  FUsedRelationships.Free;
  FRecordsAlreadyoutput.Free;
//  FQuery.Free;
  FDTD.Free;
  inherited Destroy;
end;


{ Public method to actually execute the export of a file }
procedure TDataOutput.Execute( iKeyList: TEditableKeyList; AInvalidKeys: TKeyList;
    const iWantObservations, iFromExportFilter : boolean);
begin
  { Store the key list we are about to export }
  dmNBNXML.KeyList.Assign(iKeyList);
  try
    dmNBNXML.KeyList.ConvertToMixedData;
  except
    on E:EKeyListError do
      raise EDataOutputError.CreateNonCritical(ResStr_ExportDataUnsuitable, E);
  end; // try
  if iWantObservations then
    PickupObservations(dmNBNXML.KeyList);
  dmNBNXML.InvalidKeys.Assign(AInvalidKeys);
  dmNBNXML.WantObservations := iWantObservations;

  OutputXMLVersion;
  OutputDocTypeDeclaration;
  OutputAppVersion;
  { The actual important bit }
  InitiateOutput(iFromExportFilter);
end;


{ If the want observations option is selected, then we must gather any
    observation records for locations and names in the output key list.  The
    observations are added to the end of the keylist }
procedure TDataOutput.PickupObservations(iKeyList : TEditableKeyList);
var
  i, lKeyCount : integer;
  lKeyField : TKeyString;
begin
  lKeyCount := iKeyList.Header.ItemCount;
  { Loop through only the pre-existing keys in the list }
  for i := 0 to lKeyCount-1 do
  begin
    lKeyField := iKeyList.Items[i].KeyField1;
    { Is it a location record }
    if IsKeyItemInTable( iKeyList, i, 'LOCATION' ) then
    begin
      { Find related events and samples }
      SetStandardQuery(dmNBNXML.qryRelatedOccurrences, ssEventsForLocation, lKeyField, AppSettings.UserId);
      iKeylist.AddQueryResults(dmNBNXML.qryRelatedOccurrences);
      SetStandardQuery(dmNBNXML.qryRelatedOccurrences, ssSamplesForLocation, lKeyField, AppSettings.UserId);
      iKeylist.AddQueryResults(dmNBNXML.qryRelatedOccurrences);
    end
    else if IsKeyItemInTable( iKeyList, i, 'NAME' ) or
            IsKeyItemInTable( iKeyList, i, 'INDIVIDUAL' ) or
            IsKeyItemInTable( iKeyList, i, 'ORGANISATION' ) then
    begin // or  a name record?
      { Find related surveys, events, samples and occurrences }
      SetStandardQuery(dmNBNXML.qryRelatedOccurrences, ssSurveysForName, lKeyField, AppSettings.UserId);
      iKeylist.AddQueryResults(dmNBNXML.qryRelatedOccurrences);
      SetStandardQuery(dmNBNXML.qryRelatedOccurrences, ssEventsForName, lKeyField, AppSettings.UserId);
      iKeylist.AddQueryResults(dmNBNXML.qryRelatedOccurrences);
      SetStandardQuery(dmNBNXML.qryRelatedOccurrences, ssSamplesForName, lKeyField, AppSettings.UserId);
      iKeylist.AddQueryResults(dmNBNXML.qryRelatedOccurrences);
      SetStandardQuery(dmNBNXML.qryRelatedOccurrences, ssOccurrencesForName, lKeyField, AppSettings.UserId);
      iKeylist.AddQueryResults(dmNBNXML.qryRelatedOccurrences);
    end; // if
  end; // for
end;


{ Returns true if a keylist item refers to an item in a given table }
function TDataOutput.IsKeyItemInTable( iKeyList : TKeyList; const iIndex : integer;
                                      const iTable : string ): boolean;
begin
  Result := ((iKeyList.Header.TableName = MIXED_DATA) and
       (CompareText(iKeyList.Items[iIndex].KeyField2, iTable)=0)) or
       (CompareText(iKeyList.Header.TableName, iTable)=0);
end;



{ Output the 'DOCTYPE' declaration at the top of the XML output file }
procedure TDataOutput.OutputDocTypeDeclaration;
begin
  OutputText(fdtd.filestrings[1] + CRLF);
  with dmNBNXML.qryLocalDTDText do
  begin
    Open;
    if RecordCount > 0 then
      OutputText('[');
    while not EOF do
    begin
      OutputText(fieldByName('TEXT').AsString);
      If RecordCount > 1 then
        OutputText(CRLF);
      Next;
    end;
    if RecordCount > 0 then begin
      OutputText(']' + CRLF);
      OutputText('>' + CRLF);
    end
  end;
end;



procedure TDataOutput.OutputXMLVersion;
begin
  OutputText(fdtd.filestrings[0] + CRLF);
end;


{ Method to Initiate the output of an XML file }
procedure TDataOutput.InitiateOutput(fromExportFilter: Boolean);
var
    lRecord : TRecordIdentifier;
    lDataset : TDataset;
    lElement : TElement;
begin
  lElement := FDTD.DocTypeElement;
  lRecord.KeyField := 'ADDIN_CLSID';  // bring back zero records
  lRecord.Key1 := '---';
  lRecord.Key2 := '';
  { Next table is an arbitrary table - could be anything as we won't use it, but
      we need a dataset for recursive calls }
  lRecord.TableName := 'DTD_FRAGMENT';
  lDataset := dmNBNXML.GetQueryObject( lRecord );
  { Call into a recursive function and hopefully we'll come out
       again someday! }
  try
    { Here, the dataset is just a dummy }
    lElement.DoOutput( lDataset, 0, nil, fromExportFilter );
  finally
    lDataset.Free;
  end;
end;

        
procedure TDataOutput.OutputAppVersion;
begin
  OutputText(Format(ResStr_FileVersion, [GetFileVersion]));
end;

end.
