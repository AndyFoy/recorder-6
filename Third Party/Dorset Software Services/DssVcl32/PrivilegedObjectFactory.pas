{===============================================================================
  Unit:         PrivilegedObjectFactory

  Defines:      TPrivilegedObjectFactory

  Description:  Factory for COM objects that support elevation.

                See <http://msdn.microsoft.com/en-us/library/ms679687.aspx>
                ('The COM Elevation Moniker') for the details of how this
                works.  See the 'PrivilegedComObj' unit for the function that
                client code uses to instantiate one of these objects as an
                administrator. 

  Created:      February 2009

  Last revision information:
    $Revision: 3 $
    $Date: 18/02/09 19:08 $
    $Author: Andrewkemp $

  Copyright © Dorset Software Services Ltd, 2009

===============================================================================}
unit PrivilegedObjectFactory;

interface

uses
  ComObj, Types, Windows;

type
  { ----------------------------------------------------------------------------
    Factory for COM objects that support elevation.
  }
  TPrivilegedObjectFactory = class(TTypedComObjectFactory)
  protected
    FAppID: TGUID;
    FAppNameResourceID: String;
    procedure UpdateRegistryForElevation(Register: Boolean);
    procedure SetAccessPermissionsForLUAServer;
  public
    constructor Create(
        const AppID: TGUID;
        AppNameResourceId: String;
        ComServer: TComServerObject;
        TypedComClass: TTypedComClass;
        const ClassID: TGUID;
        Instancing: TClassInstancing;
        ThreadingModel: TThreadingModel = tmSingle);
    procedure UpdateRegistry(Register: Boolean); override;
  end;


implementation

{$WARN SYMBOL_PLATFORM OFF}

uses
  SysUtils, ComConst, PrivilegedComObj;

{ a bit of missing Windows API }
const
  SDDL_REVISION_1 = 1;  

function ConvertStringSecurityDescriptorToSecurityDescriptor(
  StringSecurityDescriptor: LPCSTR;
  StringSDRevision: DWORD;
  var SecurityDescriptor: PSecurityDescriptor;
  SecurityDescriptorSize: PULONG): BOOL; stdcall;
  external advapi32 name 'ConvertStringSecurityDescriptorToSecurityDescriptorA';


{ ------------------------------------------------------------------------------
  Sets a DWORD value in the registry, creating the key if necessary.
}  
procedure CreateRegKeyAndDWordValue(
  const Key, ValueName: string;
  Value: DWord);
var
  Handle: HKey;
  Status, Disposition: Integer;
begin
  Status := RegCreateKeyEx(HKEY_CLASSES_ROOT, PChar(Key), 0, '',
      REG_OPTION_NON_VOLATILE, KEY_READ or KEY_WRITE, nil, Handle,
      @Disposition);
  if Status = 0 then
  begin
    Status := RegSetValueEx(Handle, PChar(ValueName), 0, REG_DWORD,
        @Value, SizeOf(DWord));
    RegCloseKey(Handle);
  end;
  if Status <> 0 then
    raise EOleRegistrationError.CreateRes(@SCreateRegKeyError);
end;


{ ------------------------------------------------------------------------------
  Constructs a new instance of the object factory.
  
  The specified application name resource is used to identify the application
  in any elevation/administrator consent prompts generated by Windows when the
  factory creates an object.
}
constructor TPrivilegedObjectFactory.Create(
  const AppID: TGUID;
  AppNameResourceId: String;
  ComServer: TComServerObject;
  TypedComClass: TTypedComClass;
  const ClassID: TGUID;
  Instancing: TClassInstancing;
  ThreadingModel: TThreadingModel = tmSingle);
begin
  inherited Create(
      ComServer,
      TypedComClass,
      ClassID,
      Instancing,
      ThreadingModel);
  FAppID := AppID;
  FAppNameResourceId := AppNameResourceId;
end;

{ ------------------------------------------------------------------------------
  Registers or unregisters the COM object class, including (on Windows Vista
  and later) the necessary registry entries for out-of-process hosting and
  elevation.
}
procedure TPrivilegedObjectFactory.UpdateRegistry(
  Register: Boolean);
begin
  if Register then
  begin
    inherited;
    if WindowsSupportsElevation then UpdateRegistryForElevation(True);
  end
  else begin
    if WindowsSupportsElevation then UpdateRegistryForElevation(False);
    inherited;
  end;  
end;

{ ------------------------------------------------------------------------------
  Creates or deletes the necessary registry entries for out-of-process hosting
  and elevation.
}
procedure TPrivilegedObjectFactory.UpdateRegistryForElevation(
  Register: Boolean);
var
  AppID: String;
  ClassID: String;
  FileName: String;
begin
  AppID := GUIDToString(FAppID);
  ClassID := GUIDToString(Self.ClassID);
  FileName := ComServer.ServerFileName;

  if not Register then
  begin
    DeleteRegKey('AppID\' + AppID);
    DeleteRegKey('CLSID\' + AppID + '\Elevation');
  end
  else begin
    // out-of-process activation
    CreateRegKey('AppID\' + AppID, '', Description);
    CreateRegKey('AppID\' + AppID, 'DllSurrogate', '');
    CreateRegKey('CLSID\' + ClassId, 'AppID', AppID);

    // elevation
    CreateRegKey(
        'CLSID\' + ClassID,
        'LocalizedString',
        '@' + FileName + ',-' + FAppNameResourceID);
    CreateRegKeyAndDWordValue('CLSID\' + ClassID + '\Elevation', 'Enabled', 1);

    // set permissions for over-the-shoulder elevation    
    SetAccessPermissionsForLUAServer;
  end;
end;

{ ------------------------------------------------------------------------------
  Sets the necessary access permissions for over-the-shoulder elevation.

  This is required to allow non-administrator users to make calls into the
  object once it has been created.
}
procedure TPrivilegedObjectFactory.SetAccessPermissionsForLUAServer;
var
  Sddl: String;
  SecDesc: PSecurityDescriptor;
  DescLength: ULONG;
  Key: String;
  Handle: HKey;
  Status, Disposition: Integer;
begin
  Sddl := 'O:BA'          // owner (O) is built-in administrators (BA)
      + 'G:BA'            // group (G) is built-in administrators (BA)
      + 'D:'              // discretionary access list (D)...
      + '(A;;0x3;;;IU)'   // ...allows (A) access to interactive users (IU)...
      + '(A;;0x3;;;SY)';  // ...and local system (SY)

  { 0x3 is the access granted in each case -- I have not been
    able to find out what this particular value means: it came
    from the MSDN article that is cited in the header comment. }
  
  Win32Check(ConvertStringSecurityDescriptorToSecurityDescriptor(
      PChar(Sddl),
      SDDL_REVISION_1,
      SecDesc,
      @DescLength));      
  try
    Key := 'AppID\' + GuidToString(FAppID);
    Status := RegCreateKeyEx(HKEY_CLASSES_ROOT, PChar(Key), 0, '',
        REG_OPTION_NON_VOLATILE, KEY_READ or KEY_WRITE, nil, Handle,
        @Disposition);
    if Status = 0 then
    begin
      Status := RegSetValueEx(Handle, 'AccessPermission', 0, REG_BINARY,
          SecDesc, DescLength);
      RegCloseKey(Handle);
    end;
    if Status <> 0 then
      raise EOleRegistrationError.CreateRes(@SCreateRegKeyError);      
  finally
    LocalFree(Cardinal(SecDesc));
  end;  
end;

end.
